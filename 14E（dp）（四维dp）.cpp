#include<bits/stdc++.h>
using namespace std;
int dp[23][23][23][2];
// 题意：
// 画骆驼峰，给你n步，要你求可以画t个骆驼峰的方案数。
// 要求骆驼峰的高度不能超过4。
// (3≤n≤20, 1≤t≤10).

// 题解：
// 四维dp。
// dp[n][t][j][s]。
// n代表点数（步长），t代表尖峰数，j代表高度，s代表上升（1）还是下降（0）的方案数。
// 初始化第一步，第一个尖峰，高度为j的是一个上升峰。
// 因为初始值看成了一个上升峰，那么步数为2时会出现下降峰。比如21，32这些。但是这些不合法。
// 所以要把步数为2时的置0就可以了。
// 转移方程：

// 一.更新上升峰（1：上升峰再加一个上升，2：下降峰加一个上升）
// dp[n][t][i][1] += ( dp[n-1][t][j][1] + dp[n-1][t-1][j][0] );

// 二.更新下降峰（1:下降峰再加一个下降，2：上升峰加一个上升）
// dp[n][t][i][0] += ( dp[n-1][t][j][0] + dp[n-1][t][j][1] );

int main()
{
	for(int i=1;i<5;i++)
	{
		dp[1][1][i][1] = 1;//边界：上升的尖峰为 1 
	}
	
	for(int k=2;k<=20;k++)
	{
		for(int l=1;l<=10;l++)
		{
			for(int i=1;i<=4;i++)
			{
				for(int j=1;j<i;j++)//更新上升的尖峰: (1：上升再加一个上升 2：下降峰加个上升)
				{
					dp[k][l][i][1] += (dp[k-1][l][j][1] + dp[k-1][l-1][j][0]); 
				}
				if(k==2)//2步不可能的情况 
				{
					dp[k][l][i][0] = 0;
				}
				else
				{
					for(int j=i+1;j<=4;j++)
					{
						//更新下降的尖峰(1:下降峰再加一个下降,2:上升峰加一个下降)
						dp[k][l][i][0] += (dp[k-1][l][j][0] + dp[k-1][l][j][1]);
					}
				} 
			}	
		}
		
		
	}
	int n , t;
	cin>>n>>t;
	int ans = 0;
	for(int i=1;i<=4;i++)
	{
		ans += dp[n][t][i][0];
	}
	cout<<ans<<endl;
	return 0;
} 